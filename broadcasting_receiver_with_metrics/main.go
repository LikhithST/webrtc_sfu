// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>
// SPDX-License-Identifier: MIT

//go:build !js
// +build !js

// broadcast demonstrates how to broadcast a video to many peers, while only requiring the broadcaster to upload once.
package main

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"
	"sync/atomic"
	"time"

	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/interceptor/pkg/stats"
	"github.com/pion/webrtc/v4"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

// we create a new custom metric of type counter
var webrtcStats = struct {
	PacketsReceived     *prometheus.GaugeVec
	PacketsLost         *prometheus.GaugeVec
	Jitter              *prometheus.GaugeVec
	BytesReceived       *prometheus.GaugeVec
	HeaderBytesReceived *prometheus.GaugeVec
	FIRCount            *prometheus.GaugeVec
	PLICount            *prometheus.GaugeVec
	NACKCount           *prometheus.GaugeVec
}{
	PacketsReceived: prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "webrtc_packets_received_total",
			Help: "Total number of packets received in WebRTC stream",
		},
		[]string{"packets_received"}, // Labels: user and stream_id to track specific streams
	),
	PacketsLost: prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "webrtc_packets_lost_total",
			Help: "Total number of packets lost in WebRTC stream",
		},
		[]string{"packets_lost"},
	),
	Jitter: prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "webrtc_jitter",
			Help: "Current jitter (in ms) in WebRTC stream",
		},
		[]string{"jitter"},
	),
	BytesReceived: prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "webrtc_bytes_received_total",
			Help: "Total bytes received in WebRTC stream",
		},
		[]string{"bytes_received"},
	),
	HeaderBytesReceived: prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "webrtc_header_bytes_received_total",
			Help: "Total header bytes received in WebRTC stream",
		},
		[]string{"header_bytes_received"},
	),
	FIRCount: prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "webrtc_fir_count_total",
			Help: "Total number of FIR (Full Intra Request) packets in WebRTC stream",
		},
		[]string{"fir_count"},
	),
	PLICount: prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "webrtc_pli_count_total",
			Help: "Total number of PLI (Picture Loss Indication) packets in WebRTC stream",
		},
		[]string{"pli_count"},
	),
	NACKCount: prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "webrtc_nack_count_total",
			Help: "Total number of NACK (Negative Acknowledgement) packets in WebRTC stream",
		},
		[]string{"nack_count"},
	),
}

func init() {
	// we need to register the counter so prometheus can collect this metric
	log.Println("init() function called")
	prometheus.MustRegister(
		webrtcStats.PacketsReceived,
		webrtcStats.PacketsLost,
		webrtcStats.Jitter,
		webrtcStats.BytesReceived,
		webrtcStats.HeaderBytesReceived,
		webrtcStats.FIRCount,
		webrtcStats.PLICount,
		webrtcStats.NACKCount,
	)
}

// nolint:gocognit, cyclop
func main() {
	port_s1 := flag.Int("port_s1", 8082, "http server port")
	port_s2 := flag.Int("port_s2", 8083, "http server port")
	flag.Parse()

	ch := make(chan string)

	sdpChan := httpSDPServer(*port_s1, ch)

	httpStaticServer(*port_s2)

	// Everything below is the Pion WebRTC API, thanks for using it ❤️.
	// offer := webrtc.SessionDescription{}
	// decode(<-sdpChan, &offer)
	fmt.Println("")

	// peerConnectionConfig := webrtc.Configuration{
	// 	ICEServers: []webrtc.ICEServer{},
	// }
	peerConnectionConfig := webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{
			{
				URLs: []string{"stun:stun.l.google.com:19302"},
			},
		},
	}

	mediaEngine := &webrtc.MediaEngine{}
	if err := mediaEngine.RegisterDefaultCodecs(); err != nil {
		panic(err)
	}

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	interceptorRegistry := &interceptor.Registry{}

	// Use the default set of Interceptors
	if err := webrtc.RegisterDefaultInterceptors(mediaEngine, interceptorRegistry); err != nil {
		panic(err)
	}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		panic(err)
	}
	interceptorRegistry.Add(intervalPliFactory)

	statsInterceptorFactory, err := stats.NewInterceptor()
	if err != nil {
		panic(err)
	} // to connected peers

	var statsGetter stats.Getter
	statsInterceptorFactory.OnNewPeerConnection(func(_ string, g stats.Getter) {
		fmt.Println("connected!!!")
		statsGetter = g
	})

	interceptorRegistry.Add(statsInterceptorFactory)

	// Create a new RTCPeerConnection
	peerConnection, err := webrtc.NewAPI(
		webrtc.WithMediaEngine(mediaEngine),
		webrtc.WithInterceptorRegistry(interceptorRegistry),
	).NewPeerConnection(peerConnectionConfig)
	if err != nil {
		panic(err)
	}
	defer func() {
		if cErr := peerConnection.Close(); cErr != nil {
			fmt.Printf("cannot close peerConnection: %v\n", cErr)
		}
	}()

	// Allow us to receive 1 video track
	if _, err = peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeVideo); err != nil {
		panic(err)
	}

	localTrackChan := make(chan *webrtc.TrackLocalStaticRTP)
	// Set a handler for when a new remote track starts, this just distributes all our packets

	peerConnection.OnTrack(func(remoteTrack *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) { //nolint: revive
		// Create a local track, all our SFU clients will be fed via this track
		fmt.Println("on_track")
		// go func() {
		// 	buf := make([]byte, 1500) // RTP Packet Buffer
		// 	for {
		// 		// Set a timeout for reading RTP packets (to prevent buffering delay)
		// 		remoteTrack.SetReadDeadline(time.Now().Add(300 * time.Millisecond))

		// 		// Read RTP packet
		// 		_, _, err := remoteTrack.Read(buf)
		// 		if err != nil {
		// 			fmt.Println("RTP Read error:", err)
		// 			return
		// 		}

		// 		fmt.Println("Received RTP packet")
		// 	}
		// }()
		localTrack, newTrackErr := webrtc.NewTrackLocalStaticRTP(remoteTrack.Codec().RTPCodecCapability, "video", "pion")
		if newTrackErr != nil {
			panic(newTrackErr)
		}

		localTrackChan <- localTrack

		go func() {
			// Print the stats for this individual track
			for {
				stats := statsGetter.Get(uint32(remoteTrack.SSRC()))

				// fmt.Printf("Stats for: %s\n", remoteTrack.Codec().MimeType)
				fmt.Println(stats.InboundRTPStreamStats)
				fmt.Println(stats.RemoteOutboundRTPStreamStats)

				// fmt.Println("-----", stats.InboundRTPStreamStats.PacketsReceived, "-----")
				webrtcStats.PacketsReceived.WithLabelValues("PacketsReceived").Add(float64(stats.InboundRTPStreamStats.PacketsReceived))
				webrtcStats.PacketsLost.WithLabelValues("PacketsLost").Add(float64(stats.InboundRTPStreamStats.PacketsLost))
				webrtcStats.Jitter.WithLabelValues("Jitter").Set(stats.InboundRTPStreamStats.Jitter)
				webrtcStats.BytesReceived.WithLabelValues("BytesReceived").Add(float64(stats.InboundRTPStreamStats.BytesReceived))
				webrtcStats.HeaderBytesReceived.WithLabelValues("HeaderBytesReceived").Add(float64(stats.InboundRTPStreamStats.HeaderBytesReceived))
				webrtcStats.FIRCount.WithLabelValues("FIRCount").Add(float64(stats.InboundRTPStreamStats.FIRCount))
				webrtcStats.PLICount.WithLabelValues("PLICount").Add(float64(stats.InboundRTPStreamStats.PLICount))
				webrtcStats.NACKCount.WithLabelValues("NACKCount").Add(float64(stats.InboundRTPStreamStats.NACKCount))

				time.Sleep(time.Second * 1)
			}
		}()

		rtpBuf := make([]byte, 1400)
		for {
			i, _, readErr := remoteTrack.Read(rtpBuf)
			if readErr != nil {
				panic(readErr)
			}

			// ErrClosedPipe means we don't have any subscribers, this is ok if no peers have connected yet
			if _, err = localTrack.Write(rtpBuf[:i]); err != nil && !errors.Is(err, io.ErrClosedPipe) {
				panic(err)
			}
		}
	})
	// ---------------------------------------------------------------------------------------------------------------------------

	var iceConnectionState atomic.Value
	iceConnectionState.Store(webrtc.ICEConnectionStateNew)

	// Set the handler for ICE connection state
	// This will notify you when the peer has connected/disconnected
	peerConnection.OnICEConnectionStateChange(func(connectionState webrtc.ICEConnectionState) {
		fmt.Printf("Connection State has changed %s \n", connectionState.String())
		iceConnectionState.Store(connectionState)
	})

	peerConnection.OnICECandidate(func(candidate *webrtc.ICECandidate) {
		if candidate != nil {
			fmt.Println("Discovered ICE Candidate:", candidate.Address)
		}
	})

	// Wait for the offer to be pasted
	offer, err := peerConnection.CreateOffer(nil)
	if err != nil {
		panic(err)
	}

	// Sets the LocalDescription, and starts our UDP listeners
	err = peerConnection.SetLocalDescription(offer)
	if err != nil {
		panic(err)
	}

	localdescription := encode(peerConnection.LocalDescription())

	resp, err := http.Post("http://localhost:8080/offer", "text/plain", bytes.NewBuffer([]byte(localdescription)))
	if err != nil {
		panic(err)
	}
	// defer resp.Body.Close()

	// Read response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	answer := webrtc.SessionDescription{}
	decode(string(body), &answer)

	// Set the remote SessionDescription
	err = peerConnection.SetRemoteDescription(answer)
	if err != nil {
		panic(err)
	}
	// ---------------------------------------------------------------------------------------------------------------------------------

	// Set the remote SessionDescription
	// err = peerConnection.SetRemoteDescription(offer)
	// if err != nil {
	// 	panic(err)
	// }

	// // Create answer
	// answer, err := peerConnection.CreateAnswer(nil)
	// if err != nil {
	// 	panic(err)
	// }

	// // Create channel that is blocked until ICE Gathering is complete
	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)

	// // Sets the LocalDescription, and starts our UDP listeners
	// err = peerConnection.SetLocalDescription(answer)
	// if err != nil {
	// 	panic(err)
	// }

	// // Block until ICE Gathering is complete, disabling trickle ICE
	// // we do this because we only can exchange one signaling message
	// // in a production application you should exchange ICE Candidates via OnICECandidate
	// fmt.Println("before")

	// <-gatherComplete

	// fmt.Println("after")

	// // Get the LocalDescription and take it to base64 so we can paste in browser
	// // fmt.Println(encode(peerConnection.LocalDescription()))
	// ch <- encode(peerConnection.LocalDescription())
	// -------------------------------------------
	localTrack := <-localTrackChan
	for {
		fmt.Println("")
		fmt.Println("Curl an base64 SDP to start sendonly peer connection")

		recvOnlyOffer := webrtc.SessionDescription{}
		decode(<-sdpChan, &recvOnlyOffer)

		// Create a new PeerConnection
		peerConnection, err := webrtc.NewPeerConnection(peerConnectionConfig)
		if err != nil {
			panic(err)
		}

		rtpSender, err := peerConnection.AddTrack(localTrack)
		if err != nil {
			fmt.Println("err add track")
			panic(err)
		}

		// Read incoming RTCP packets
		// Before these packets are returned they are processed by interceptors. For things
		// like NACK this needs to be called.
		go func() {
			rtcpBuf := make([]byte, 1500)
			for {
				if _, _, rtcpErr := rtpSender.Read(rtcpBuf); rtcpErr != nil {
					return
				}
			}
		}()

		// Set the remote SessionDescription
		err = peerConnection.SetRemoteDescription(recvOnlyOffer)
		if err != nil {
			fmt.Println("err SetRemoteDescription")

			panic(err)
		}

		// Create answer
		answer, err := peerConnection.CreateAnswer(nil)
		if err != nil {
			fmt.Println("err CreateAnswer")

			panic(err)
		}

		// Create channel that is blocked until ICE Gathering is complete
		gatherComplete = webrtc.GatheringCompletePromise(peerConnection)

		// Sets the LocalDescription, and starts our UDP listeners
		err = peerConnection.SetLocalDescription(answer)
		if err != nil {
			panic(err)
		}

		// Block until ICE Gathering is complete, disabling trickle ICE
		// we do this because we only can exchange one signaling message
		// in a production application you should exchange ICE Candidates via OnICECandidate
		<-gatherComplete

		// Get the LocalDescription and take it to base64 so we can paste in browser
		// fmt.Println(encode(peerConnection.LocalDescription()))
		// send to channel A
		fmt.Println("waiting to send")

		ch <- encode(peerConnection.LocalDescription())

	}
}

// JSON encode + base64 a SessionDescription.
func encode(obj *webrtc.SessionDescription) string {
	b, err := json.Marshal(obj)
	if err != nil {
		panic(err)
	}

	return base64.StdEncoding.EncodeToString(b)
}

// Decode a base64 and unmarshal JSON into a SessionDescription.
func decode(in string, obj *webrtc.SessionDescription) {
	// fmt.Printf(" incoming data %#v", in)
	b, err := base64.StdEncoding.DecodeString(in)
	if err != nil {
		panic(err)
	}

	if err = json.Unmarshal(b, obj); err != nil {
		panic(err)
	}
}

// httpSDPServer starts a HTTP Server that consumes SDPs.
func httpSDPServer(port int, ch chan string) chan string {
	sdpChan := make(chan string)

	mux_s1 := http.NewServeMux()
	mux_s1.Handle("/metrics", promhttp.Handler())
	mux_s1.HandleFunc("/offer", func(res http.ResponseWriter, req *http.Request) {
		res.Header().Set("Access-Control-Allow-Origin", "*")
		res.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS")
		res.Header().Set("Access-Control-Allow-Headers", "Content-Type")

		// Handle preflight request
		if req.Method == "OPTIONS" {
			res.WriteHeader(http.StatusOK)
			return
		}

		if req.Method != http.MethodPost {
			http.Error(res, "Invalid request method", http.StatusMethodNotAllowed)
			return
		}
		body, _ := io.ReadAll(req.Body)
		sdpChan <- string(body)
		// recieve from channel A
		response_string := <-ch
		// fmt.Fprintf(res, response_string) //nolint: errcheck
		// fmt.Printf("%+v", response_string)
		res.Header().Set("Content-Type", "text/plain")
		res.Write([]byte(response_string))

	})

	go func() {
		// nolint: gosec
		panic(http.ListenAndServe(":"+strconv.Itoa(port), mux_s1))
	}()

	return sdpChan
}

func httpStaticServer(port int) {
	mux_s2 := http.NewServeMux()
	fs := http.FileServer(http.Dir("static"))
	mux_s2.Handle("/", fs)

	go func() {
		// nolint: gosec
		panic(http.ListenAndServe(":"+strconv.Itoa(port), mux_s2))
	}()
}
